using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Mapbox.Unity.Location;
using Mapbox.Unity.Map;
using Mapbox.CheapRulerCs;
using Mapbox.Utils;
using UnityARInterface;

public class PlaceMapboxMap : MonoBehaviour
{
    private bool MapPlaced;
    //for editor version
    
    public GameObject focusSquare;
    
    public float maxRayDistance = 30.0f;
    public LayerMask collisionLayerMask;
    public float findingSquareDist = 0.5f;
    public Transform _mapTransform;
    public AbstractMap _map;
    public GameObject MapBase;

    protected Location _currentLocation;
    public Location CurrentLocation
    {
        get
        {
            return _currentLocation;
        }
    }


    ILocationProvider _locationProvider;
    ILocationProvider LocationProvider

    {
        get
        {
            if (_locationProvider == null)
            {
                _locationProvider = LocationProviderFactory.Instance.DefaultLocationProvider;
            }

            return _locationProvider;
        }
    }
    

    // Update is called once per frame
    void Update()
    {
        if (!MapPlaced && Input.touchCount > 0 && Input.GetTouch(0).phase == TouchPhase.Began)
        {
            InstantiateMap();

        }

        if (!MapPlaced && Input.GetMouseButtonDown(0))
        {
            InstantiateMap();

        }
        
    }
    
    
    void InstantiateMap()
    {
        Debug.Log("Instantiate Map");

        //use center of screen for focusing
        Vector3 center = new Vector3(Screen.width / 2, Screen.height / 2, findingSquareDist);

        Ray ray = Camera.main.ScreenPointToRay(center);
        RaycastHit hit;

        //we'll try to hit one of the plane collider gameobjects that were generated by the plugin
        //effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
        if (Physics.Raycast(ray, out hit, maxRayDistance, collisionLayerMask))
        {
            var position = hit.point;
            
            position.y += 0.2f;
            _mapTransform.gameObject.SetActive(true);
            _mapTransform.position = position;
            MapPlaced = true;

            // Turn off Focus Square!!
            focusSquare.SetActive(false);
            // Turn on Map Base!!
            MapBase.SetActive(true);
        
            
            var direction = ray.direction;
            direction.y = 0;
            _mapTransform.rotation = Quaternion.LookRotation(direction);
            Vector3 rotation = _mapTransform.rotation.eulerAngles;
            float missing = rotation.y % 45;
            rotation.y += missing > 23 ? 45 - missing : - missing;
            _mapTransform.rotation = Quaternion.Euler(rotation); 
            
            // Change Vector3 values to adjust map size
            UpdateShaderValues(_mapTransform.position, new Vector3(2, 2, 2), _mapTransform.rotation);

        }

    }
    
    void UpdateShaderValues(Vector3 position, Vector3 localScale, Quaternion rotation)
    {

        Shader.SetGlobalVector("_Origin", new Vector4(
            position.x,
            position.y,
            position.z,
            0f));
        Shader.SetGlobalVector("_BoxRotation", new Vector4(
            rotation.eulerAngles.x,
            rotation.eulerAngles.y,
            rotation.eulerAngles.z,
            0f));

        Shader.SetGlobalVector("_BoxSize", new Vector4(
            localScale.x,
            localScale.y,
            localScale.z,
            0f));
    }
    
}
